// SPDX-FileCopyrightText: 2025 Madeline Baggins <madeline@baggins.family>
// 
// SPDX-License-Identifier: GPL-3.0-only

function waitForElementById(id, callback, interval = 100) {
  const checkInterval = setInterval(() => {
    let element = document.getElementById(id);
    if (element !== null) {
      clearInterval(checkInterval);
      callback(element);
    }
  }, interval);
}

var app = Elm.Main.init({
  node: document.getElementById('elmroot')
});
let wasm_js = (location.toString().split("recipe/")[0] + 'pkg/wasm.js');
async function run() {
  let wasm = await import(wasm_js);
  await wasm.default();
  let recipe = null;
  let recipe_md = null;
  // The callback for changing a recipe's markdown.
  app.ports.showRecipe.subscribe(async function(content) {
    recipe = wasm.recipe(content);
    waitForElementById('recipe', (element) => {
      recipe_md = recipe.markdown();
      element.innerHTML = recipe.html();
    });
  });
  // The callback for scaling the recipe
  function parseFraction(fraction) {
    const parts = fraction.split('/');
    if (parts.length == 2) {
      const numerator = parseFloat(parts[0]);
      const denominator = parseFloat(parts[1]);
      if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
        return numerator / denominator;
      }
    }
    return parseFloat(fraction);
  }
  app.ports.scaleRecipe.subscribe(async function(factor) {
    recipe_md = recipe.scale(parseFraction(factor)).markdown();
    document.getElementById('recipe').innerHTML = recipe.scale(parseFraction(factor)).html();
  });
  app.ports.print.subscribe(async function(_) {
    await fetch("/print/", {
      method: "POST",
      body: recipe_md
    });
  })
  app.ports.ready.send("");
}
run()
</script>
</div>
</body>
</html>
